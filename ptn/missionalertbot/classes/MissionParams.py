from ptn.missionalertbot.classes.CarrierData import CarrierData
from ptn.missionalertbot.classes.ChannelDefs import ChannelDefs
from ptn.missionalertbot._metadata import __version__

class MissionParams:
    """
    A class to store all parameters relating to mission generation.
    This class can be pickled into the missions database for later retrieval.
    Note we cannot pickle discord.py weak objects e.g. interactions
    """

    def __init__(self, info_dict=None):
        """
        Class represents a mission object as returned from the database.

        :param sqlite.Row info_dict: A single row from the sqlite query.
        """

        if info_dict:
            # Convert input to a dictionary
            info_dict = dict(info_dict)
        else:
            info_dict = dict()

        self.mission_version = info_dict.get('mission_version', __version__) # the version of MAB the mission was generated under
        self.returnflag: bool = info_dict.get('returnflag', True) # used in various places during mission gen to indicate an error if false
        self.training: bool = info_dict.get('training', False) # whether this is a training mission or not
        self.channel_defs: ChannelDefs = info_dict.get('channel_defs', None) # defines channels used by mission generator
        self.channel_alerts_actual: int = info_dict.get('channel_alerts_actual', None) # ID of alerts channel used when sending mission, as defined from ChannelDefs
        self.role_ping_actual: int = info_dict.get('channel_alerts_actual', None) # ID of role ping used by bot when sending mission
        self.copypaste_embed = info_dict.get('copypaste_embed', None) # embed containing the copy/paste string for the command used
        self.carrier_name_search_term: str = info_dict.get('carrier_name_search_term', None) # the carrier name fragment to search for
        self.commodity_search_term: str = info_dict.get('commodity_search_term', None) # the commodity name fragment to search for
        self.system: str = info_dict.get('system', None) # the target system
        self.station: str = info_dict.get('station', None) # target station
        self.profit_raw = info_dict.get('profit_raw', None) # profit STR as entered by user
        self.profit = info_dict.get('profit', None) # profit as int or float
        self.pads: str = info_dict.get('pads', None) # size of largest landing pad L or M
        self.demand_raw = info_dict.get('demand_raw', None) # raw value entered for demand/supply
        self.demand = info_dict.get('demand', None) # demand as int or float
        self.mission_type: str = info_dict.get('mission_type', None) # whether the mission is loading or unloading
        self.edmc_off = info_dict.get('edmc_off', None) # whether the mission is EDMC off flagged
        self.carrier_data: CarrierData = info_dict.get('carrier_data', None) # carrier data class retrieved from db
        self.commodity_name: str = info_dict.get('commodity_name', None) # commodity name
        self.reddit_img_name = info_dict.get('reddit_img_name', None) # the Reddit image file name
        self.discord_img_name = info_dict.get('discord_img_name', None) # the Discord image file name
        self.cco_message_text: str = info_dict.get('cco_message_text', None) # message text entered by user
        self.timestamp = info_dict.get('timestamp', None) # the posix time the mission was generated
        self.reddit_title: str = info_dict.get('reddit_title', None) # title for the subreddit post
        self.reddit_body: str = info_dict.get('reddit_body', None) # body text for the top-level comment on the subreddit post
        self.reddit_post_id = info_dict.get('reddit_post_id', None) # the ID of the mission's Reddit post
        self.reddit_post_url = info_dict.get('reddit_post_url', None) # the URL of the mission's Reddit post
        self.reddit_comment_id = info_dict.get('reddit_comment_id', None) # the ID of the mission's autogenerated Reddit top comment
        self.reddit_comment_url = info_dict.get('reddit_comment_url', None) # the URL of the mission's autogenerated Reddit top comment
        self.discord_text: str = info_dict.get('discord_text', None) # the text used for the trade alert sent to Discord
        self.discord_msg_content: str = info_dict.get('discord_msg_content', None) # non-embed content used to emphasise edmc-off
        self.discord_embeds = info_dict.get('discord_embeds', None) # embeds used for Discord channels/webhooks
        self.discord_alert_id = info_dict.get('discord_alert_id', None) # the message ID of the Discord trade alerts entry
        self.discord_msg_id = info_dict.get('discord_msg_id', None) # ID of the message sent to the carrier channel
        self.mission_temp_channel_id = info_dict.get('mission_temp_channel_id', None) # the channel ID of the Discord carrier mission channel
        self.notify_msg_id = info_dict.get('notify_msg_id', None) # ID of the message notifying haulers
        self.webhook_urls: list = info_dict.get('webhook_urls', []) # a list of the URLs for any webhooks used
        self.webhook_names: list = info_dict.get('webhook_names', []) # identifiers for webhook URLs
        self.webhook_msg_ids: list = info_dict.get('webhook_msg_ids', []) # a list of the IDs of any messages sent via webhook
        self.webhook_jump_urls: list = info_dict.get('webhook_jump_urls', []) # webhook jump URL
        self.original_message_embeds: list = info_dict.get('original_message_embeds', []) # embeds to attach to original response
        self.sendflags: list = info_dict.get('sendflags', ['d', 'n', 'r', 'w']) # mission send flags in the form of a list. Defaults are discord, notify haulers, reddit, webhooks
        self.booze_cruise: bool = info_dict.get('booze_cruise', False) # whether the booze cruise channels are open or not


    def print_values(self):
        try:
            print(f"version: {self.version}")
            print(f"returnflag: {self.returnflag}")
            print(f"training: {self.training}")
            print(f"channel_defs: {self.channel_defs}")
            print(f"channel_alerts_actual: {self.channel_alerts_actual}")
            print(f"role_ping_actual: {self.role_ping_actual}")
            print(f"copypaste_embed: {self.copypaste_embed}")
            print(f"carrier_name_search_term: {self.carrier_name_search_term}")
            print(f"commodity_search_term: {self.commodity_search_term}")
            print(f"system: {self.system}")
            print(f"station: {self.station}")
            print(f"profit_raw: {self.profit_raw}")
            print(f"profit: {self.profit}")
            print(f"pads: {self.pads}")
            print(f"demand: {self.demand}")
            print(f"mission_type: {self.mission_type}")
            print(f"edmc_off: {self.edmc_off}")
            print(f"carrier_data: {self.carrier_data}")
            print(f"commodity_name: {self.commodity_name}")
            print(f"reddit_img_name: {self.reddit_img_name}")
            print(f"discord_img_name: {self.discord_img_name}")
            print(f"cco_message_text: {self.cco_message_text}")
            print(f"timestamp: {self.timestamp}")
            print(f"reddit_title: {self.reddit_title}")
            print(f"reddit_body: {self.reddit_body}")
            print(f"reddit_post_id: {self.reddit_post_id}")
            print(f"reddit_post_url: {self.reddit_post_url}")
            print(f"reddit_comment_id: {self.reddit_comment_id}")
            print(f"reddit_comment_url: {self.reddit_comment_url}")
            print(f"discord_text: {self.discord_text}")
            print(f"discord_msg_content: {self.discord_msg_content}")
            print(f"discord_alert_id: {self.discord_alert_id}")
            print(f"discord_msg_id: {self.discord_msg_id}")
            print(f"mission_temp_channel_id: {self.mission_temp_channel_id}")
            print(f"notify_msg_id: {self.notify_msg_id}")
            print(f"webhook_urls: {self.webhook_urls}")
            print(f"webhook_msg_ids: {self.webhook_msg_ids}")
            print(f"webhook_jump_urls: {self.webhook_jump_urls}")
            print(f"sendflags: {self.sendflags}")
            print(f"booze_cruise: {self.booze_cruise}")
        except: pass # for values which haven't been incorporated yet

    def to_dictionary(self):
        """
        Formats the mission data into a dictionary for easy access.

        :returns: A dictionary representation for the mission data.
        :rtype: dict
        """
        response = {}
        for key, value in vars(self).items():
            if value is not None:
                response[key] = value
        return response

    def __str__(self):
        """
        Overloads str to return a readable object

        :rtype: str
        """
        return (
            "‚è© Mission Params:\n"
            f"version: {self.version}\n"
            f"returnflag: {self.returnflag}\n"
            f"training: {self.training}\n"
            f"channel_defs: {self.channel_defs}\n"
            f"channel_alerts_actual: {self.channel_alerts_actual}\n"
            f"role_ping_actual: {self.role_ping_actual}\n"
            f"copypaste_embed: {self.copypaste_embed}\n"
            f"carrier_name_search_term: {self.carrier_name_search_term}\n"
            f"commodity_search_term: {self.commodity_search_term}\n"
            f"system: {self.system}\n"
            f"station: {self.station}\n"
            f"profit_raw: {self.profit_raw}\n"
            f"profit: {self.profit}\n"
            f"pads: {self.pads}\n"
            f"demand: {self.demand}\n"
            f"mission_type: {self.mission_type}\n"
            f"edmc_off: {self.edmc_off}\n"
            f"carrier_data: {self.carrier_data}\n"
            f"commodity_name: {self.commodity_name}\n"
            f"reddit_img_name: {self.reddit_img_name}\n"
            f"discord_img_name: {self.discord_img_name}\n"
            f"cco_message_text: {self.cco_message_text}\n"
            f"timestamp: {self.timestamp}\n"
            f"reddit_title: {self.reddit_title}\n"
            f"reddit_body: {self.reddit_body}\n"
            f"reddit_post_id: {self.reddit_post_id}\n"
            f"reddit_post_url: {self.reddit_post_url}\n"
            f"reddit_comment_id: {self.reddit_comment_id}\n"
            f"reddit_comment_url: {self.reddit_comment_url}\n"
            f"discord_text: {self.discord_text}\n"
            f"discord_msg_content: {self.discord_msg_content}\n"
            f"discord_alert_id: {self.discord_alert_id}\n"
            f"discord_msg_id: {self.discord_msg_id}\n"
            f"mission_temp_channel_id: {self.mission_temp_channel_id}\n"
            f"notify_msg_id: {self.notify_msg_id}\n"
            f"webhook_urls: {self.webhook_urls}\n"
            f"webhook_msg_ids: {self.webhook_msg_ids}\n"
            f"webhook_jump_urls: {self.webhook_jump_urls}\n"
            f"sendflags: {self.sendflags}\n"
            f"booze_cruise: {self.booze_cruise}"
        )

    def __bool__(self):
        """
        Override boolean to check if any values are set, if yes then return True, else False, where false is an empty
        class.

        :rtype: bool
        """
        return any([value for key, value in vars(self).items() if value])